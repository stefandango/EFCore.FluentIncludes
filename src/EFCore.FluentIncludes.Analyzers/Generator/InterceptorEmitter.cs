using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace EFCore.FluentIncludes.Analyzers.Generator;

/// <summary>
/// Generates C# interceptor code for FluentIncludes method calls.
/// </summary>
internal static class InterceptorEmitter
{
    /// <summary>
    /// Generates interceptor code for the given include calls.
    /// </summary>
    public static string GenerateInterceptors(ImmutableArray<IncludeCallInfo> calls, CancellationToken ct)
    {
        if (calls.IsDefaultOrEmpty)
        {
            return string.Empty;
        }

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using Microsoft.EntityFrameworkCore;");
        sb.AppendLine();
        sb.AppendLine("namespace EFCore.FluentIncludes.Generated");
        sb.AppendLine("{");
        sb.AppendLine("    // Interceptor attribute for .NET 10+");
        sb.AppendLine("    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]");
        sb.AppendLine("    file sealed class InterceptsLocationAttribute : Attribute");
        sb.AppendLine("    {");
        sb.AppendLine("        public InterceptsLocationAttribute(int version, string data) { }");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    file static class FluentIncludesInterceptors");
        sb.AppendLine("    {");

        int interceptorIndex = 0;

        foreach (var call in calls)
        {
            ct.ThrowIfCancellationRequested();

            if (!call.CanGenerate)
            {
                // Generate a comment about why this call uses fallback
                sb.AppendLine($"        // Fallback: {call.MethodName} at {call.FilePath}:{call.Line} - {call.FallbackReason}");
                continue;
            }

            GenerateInterceptor(sb, call, interceptorIndex++, ct);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateInterceptor(StringBuilder sb, IncludeCallInfo call, int index, CancellationToken ct)
    {
        // Generate the InterceptsLocation attribute using .NET 10 format
        var interceptData = GenerateInterceptData(call);

        sb.AppendLine();
        sb.AppendLine($"        // Intercepting: {call.MethodName} at {call.FilePath}:{call.Line}:{call.Column}");
        sb.AppendLine($"        [InterceptsLocation(1, \"{interceptData}\")]");

        // Generate method signature matching the original
        switch (call.MethodName)
        {
            case "IncludePaths":
                GenerateIncludePathsInterceptor(sb, call, index, ct);
                break;

            case "IncludePath":
                GenerateIncludePathInterceptor(sb, call, index, ct);
                break;

            case "IncludePathsIf":
                GenerateIncludePathsIfInterceptor(sb, call, index, ct);
                break;

            case "IncludeFrom":
                GenerateIncludeFromInterceptor(sb, call, index, ct);
                break;

            case "IncludeFromIf":
                GenerateIncludeFromIfInterceptor(sb, call, index, ct);
                break;
        }
    }

    private static void GenerateIncludePathsInterceptor(StringBuilder sb, IncludeCallInfo call, int index, CancellationToken ct)
    {
        var entityType = call.EntityTypeFullName;

        sb.AppendLine($"        internal static IQueryable<{entityType}> IncludePaths_{index}(");
        sb.AppendLine($"            this IQueryable<{entityType}> query,");
        sb.AppendLine($"            params Expression<Func<{entityType}, object?>>[] paths)");
        sb.AppendLine("        {");

        GenerateIncludeChain(sb, call, ct);

        sb.AppendLine("        }");
    }

    private static void GenerateIncludePathInterceptor(StringBuilder sb, IncludeCallInfo call, int index, CancellationToken ct)
    {
        var entityType = call.EntityTypeFullName;

        sb.AppendLine($"        internal static IQueryable<{entityType}> IncludePath_{index}<TProperty>(");
        sb.AppendLine($"            this IQueryable<{entityType}> query,");
        sb.AppendLine($"            Expression<Func<{entityType}, TProperty>> path)");
        sb.AppendLine("        {");

        GenerateIncludeChain(sb, call, ct);

        sb.AppendLine("        }");
    }

    private static void GenerateIncludePathsIfInterceptor(StringBuilder sb, IncludeCallInfo call, int index, CancellationToken ct)
    {
        var entityType = call.EntityTypeFullName;

        sb.AppendLine($"        internal static IQueryable<{entityType}> IncludePathsIf_{index}(");
        sb.AppendLine($"            this IQueryable<{entityType}> query,");
        sb.AppendLine("            bool condition,");
        sb.AppendLine($"            params Expression<Func<{entityType}, object?>>[] paths)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (!condition) return query;");

        GenerateIncludeChain(sb, call, ct);

        sb.AppendLine("        }");
    }

    private static void GenerateIncludeFromInterceptor(StringBuilder sb, IncludeCallInfo call, int index, CancellationToken ct)
    {
        var entityType = call.EntityTypeFullName;

        // For IncludeFrom, we need to handle the base path + sub-paths
        // This is more complex - for now, generate a simpler version
        sb.AppendLine($"        internal static IQueryable<{entityType}> IncludeFrom_{index}<TNav>(");
        sb.AppendLine($"            this IQueryable<{entityType}> query,");
        sb.AppendLine($"            Expression<Func<{entityType}, TNav>> basePath,");
        sb.AppendLine($"            params Expression<Func<TNav, object?>>[] subPaths)");
        sb.AppendLine("        {");

        GenerateIncludeChain(sb, call, ct);

        sb.AppendLine("        }");
    }

    private static void GenerateIncludeFromIfInterceptor(StringBuilder sb, IncludeCallInfo call, int index, CancellationToken ct)
    {
        var entityType = call.EntityTypeFullName;

        sb.AppendLine($"        internal static IQueryable<{entityType}> IncludeFromIf_{index}<TNav>(");
        sb.AppendLine($"            this IQueryable<{entityType}> query,");
        sb.AppendLine("            bool condition,");
        sb.AppendLine($"            Expression<Func<{entityType}, TNav>> basePath,");
        sb.AppendLine($"            params Expression<Func<TNav, object?>>[] subPaths)");
        sb.AppendLine("        {");
        sb.AppendLine("            if (!condition) return query;");

        GenerateIncludeChain(sb, call, ct);

        sb.AppendLine("        }");
    }

    private static void GenerateIncludeChain(StringBuilder sb, IncludeCallInfo call, CancellationToken ct)
    {
        if (call.Lambdas.IsDefaultOrEmpty)
        {
            sb.AppendLine("            return query;");
            return;
        }

        // Build Include/ThenInclude chains for each lambda
        foreach (var lambda in call.Lambdas)
        {
            ct.ThrowIfCancellationRequested();

            if (lambda.Segments.IsDefaultOrEmpty)
            {
                continue;
            }

            var includeChain = IncludeChainBuilder.BuildIncludeChain(lambda.Segments, call.EntityTypeFullName);
            sb.AppendLine($"            query = query{includeChain};");
        }

        sb.AppendLine("            return query;");
    }

    /// <summary>
    /// Generates the base64-encoded interceptor location data for .NET 10 format.
    /// Format: version 1 uses checksum + utf8 file path + line + column.
    /// </summary>
    private static string GenerateInterceptData(IncludeCallInfo call)
    {
        // The .NET 10 interceptor format uses a base64-encoded string containing:
        // - A content hash of the syntax tree
        // - The position within the file
        // This is generated by the compiler utilities
        return GenerateInterceptsLocationData(call.SyntaxTree, call.InvocationSpan.Start);
    }

    /// <summary>
    /// Generates the InterceptsLocation data string for .NET 10 format.
    /// </summary>
    private static string GenerateInterceptsLocationData(SyntaxTree syntaxTree, int position)
    {
        // Get the checksum of the syntax tree
        var text = syntaxTree.GetText();
        var checksum = text.GetContentHash();

        // Get file path as UTF-8 bytes
        var filePath = syntaxTree.FilePath ?? "";
        var filePathBytes = Encoding.UTF8.GetBytes(filePath);

        // Build the data: checksum (16 bytes) + filePath length (4 bytes) + filePath + position (4 bytes)
        using var ms = new MemoryStream();
        using var writer = new BinaryWriter(ms);

        // Write checksum
        writer.Write(checksum.ToArray());

        // Write file path with length prefix
        writer.Write(filePathBytes.Length);
        writer.Write(filePathBytes);

        // Write position
        writer.Write(position);

        return Convert.ToBase64String(ms.ToArray());
    }
}
